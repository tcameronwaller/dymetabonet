--------------------------------------------------
Notes: Scrap Code For Project Profondeur
--------------------------------------------------

--------------------------------------------------
15 December 2017

----------
Search Menu

Initialize View
Create search field and list of options

"
// Create container.
var container = self.document.createElement("span");
self.container.appendChild(container);
// Create list of options.
var listIdentifier = "set-" + self.category + "-options-list";
var list = self.document.createElement("datalist");
container.appendChild(self.list);
var list.setAttribute("id", listIdentifier);
// Create search tool.
var search = self.document.createElement("input");
container.appendChild(search);
search.setAttribute("type", "search");
search.setAttribute("list", listIdentifier);
search.setAttribute("placeholder", "search " + self.category);
search.setAttribute("autocomplete", "off");
// Activate behavior.
// Options from datalist elements do not report events.
// Rather, search input elements report events.
// Respond to event on input search element and access relevant information
// that associates with the element.
search.addEventListener("change", function (event) {
  // Element on which the event originated is event.currentTarget.
  // Determine the search's value, the name of the attribute's value.
  var name = event.currentTarget.value;
  // Determine the search's list.
  var list = event.currentTarget.list;
  var options = list.getElementsByTagName("option");
  var names = General.extractValuesDocumentElements(options);
  // Determine whether the search value matches a valid option.
  if (names.includes(name)) {
    // The search value matches a valid option.
    // Determine the identifier of the attribute's value.
    var valueRecord = self.state.setsSummaries[self.category].find(function (record) {
      var recordName = SetMenuView.accessAttributeValueName({
        attribute: self.category,
        value: record.value,
        state: self.state
      });
      return recordName === name;
    });
    // Call action.
    Action.changeSetsFilters({
      value: valueRecord.value,
      attribute: self.category,
      state: self.state
    });
  }
  // Remove the search's value.
  event.currentTarget.value = "";
});
"

Restore View
Restore list of options

"
// Create options within list.
// Select parent.
var list = d3.select(self.list);
// Create children elements by association to data.
var dataElements = list
.selectAll("option").data(self.state.setsSummaries[self.category]);
dataElements.exit().remove();
var novelElements = dataElements.enter().append("option");
self.options = novelElements.merge(dataElements);
// Assign attributes to elements.
self.options
.text(function (element, index, nodes) {
  // Determine whether the option corresponds to a current selection of the
  // attribute's value.
  var selection = SetMenuView.determineSetSelection({
    value: element.value,
    attribute: element.attribute,
    state: self.state
  });
  if (selection) {
    var selection = "selection";
  } else {
    var selection = "";
  }
  return selection;
})
.attr("value", function (element, index, nodes) {
  var name = SetMenuView.accessAttributeValueName({
    attribute: element.attribute,
    value: element.value,
    state: self.state
  });
  return name;
});
"

--------------------------------------------------
3 November 2017

----------
  /**
  * Determines whether a reaction passes filters by its values of attributes.
  * @param {Object} parameters.filterSets Information about a reaction's
  * metabolites and sets that pass filters.
  * @param {Object} reaction Information about a reaction.
  * @returns {boolean} Whether the reaction passes filters.
  */
  static determineReactionPassFilters(filterSets, reaction) {
    // TODO: I'll need a separate function for the access reactions...
    // TODO: Eliminate the special requirement for transport reactions... I'll worry about that with candidate reactions.
    // Requirements for reaction to pass filters depend on the reaction's main
    // behavior.
    // Determine whether reaction involves transport.
    if (reaction.transport) {
      // Reaction involves transport of a metabolite between different
      // compartments.
      // A single reaction can facilitate multiple transport events.
      // Reaction only passes filters by compartment if multiple compartments of
      // any transport event pass filters.
      var compartments = reaction.transports.some(function (transport) {
        var matches = transport.compartments.filter(function (compartment) {
          return filterSets.compartments.includes(compartment);
        });
        return matches.length > 1;
      });
    } else {
      // Reaction does not involve transport of a metabolite between different
      // compartments.
      // Reaction only passes filters by compartment if it has any compartments
      // that pass filters.
      var compartments = filterSets.compartments.length > 0;
    }
    var processes = reactionRecord.processes.length > 0;
    var metabolites = reactionRecord.metabolites.length > 0;
    return (compartments && processes && metabolites);
  }

--------------------------------------------------
17 September 2017

----------
    self.nodesMarksGroup = self.nodesGroup.append("g");
    // Create visual representations of nodes' entities.
    var dataNodesMarks = nodesMarksGroup
    .selectAll("circle, ellipse").data(self.nodesRecords);
    dataNodesMarks.exit().remove();
    var novelNodesMarks = dataNodesMarks.enter().append(function (data) {
      // Append different types of elements for different types of entities.
      if (data.entity === "metabolite") {
        // Node represents a metabolite.
        return self
        .document.createElementNS("http://www.w3.org/2000/svg", "circle");
      } else if (data.entity === "reaction") {
        // Node represents a reaction.
        return self
        .document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      }
    });
    self.nodesMarks = novelNodesMarks.merge(dataNodesMarks);
    self.nodesMarks.append("title").text(function (data) {
      return data.name;
    });
    self.nodesMarks.attr("id", function (data) {
      return data.identifier;
    });
    self.nodesMarks.classed("node", true);
    self.nodesMarks.classed("mark", true);
    self.nodesMarks.classed("metabolite", function (data) {
      return data.entity === "metabolite";
    });
    self.nodesMarks.classed("reaction", function (data) {
      return data.entity === "reaction";
    });
    self.nodesMarks.classed("simplification", function (data) {
      return data.simplification;
    });

--------------------------------------------------
12 September 2017

----------
Assigning position from positions of other elements.

    self.nodesReactionsMarks
    .attr("cx", function (data) {
      // Access coordinates of position nodes from the original records for the
      // nodes.
      var positionsRecords = data.positions.map(function (identifier) {
        return self.model.reactionsPositionNodes.find(function (record) {
          return record.identifier === identifier;
        });
      });
      var positions = General.collectValueFromObjects("x", positionsRecords);
      var position = General.computeElementsMean(positions);
      return Math.max(radius, Math.min(self.graphWidth - radius, position));
    })
    .attr("cy", function (data) {
      // Access coordinates of position nodes from the original records for the
      // nodes.
      var positionsRecords = data.positions.map(function (identifier) {
        return self.model.reactionsPositionNodes.find(function (record) {
          return record.identifier === identifier;
        });
      });
      var positions = General.collectValueFromObjects("y", positionsRecords);
      var position = General.computeElementsMean(positions);
      return Math.max(radius, Math.min(self.graphHeight - radius, position));
    });

--------------------------------------------------
6 September 2017

----------
    var dataNodesMarks = nodesMarksGroup
    .selectAll("circle, ellipse").data(self.nodesPositionRecords);
    dataNodesMarks.exit().remove();
    var novelNodesMarks = dataNodesMarks.enter().append(function (data) {
      // Append different types of markers for different types of entities.
      if (data.entity === "metabolite") {
        // Node is for a metabolite.
        return self
        .document.createElementNS("http://www.w3.org/2000/svg", "circle");
      } else if (data.entity === "reaction") {
        // Node is for a reaction.
        return self
        .document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
      }
    });

--------------------------------------------------
18 July 2017

----------
    /**
     * Filters elements from the Document Object Model (DOM) by specific values
     * of a specific attribute.
     * @param {Object} parameters Destructured object of parameters.
     * @param {Array<string>} parameters.values Values of the attribute.
     * @param {string} parameters.attribute Attribute of interest.
     * @param {Array<Object>} parameters.elements Elements in the Document
     * Object Model (DOM).
     */
    static filterDocumentElements({values, attribute, elements} = {}) {
        // TODO: I encountered bizarre problems getting this function to work.
        // TODO: I suspect weird things might involve the live HTML collection or something.
        return Array.from(elements).filter(function (element) {
            var checkAttribute = element.hasAttribute(attribute);
            var checkValues = values.includes(element.getAttribute(attribute));
            return checkAttribute && checkValues;
        });
    }

--------------------------------------------------
13 July 2017

----------

/**
 * Functionality of utility for counting the metabolic entities that belong to
 * sets according to their values of attributes.
 * This class does not store any attributes and does not require instantiation.
 * This class stores methods for external utility.
 */
class CardinalityOld {
    // Master control of cardinality procedure.
    /**
     * Collects cardinalities of sets for all values of all attributes.
     * @param {Array<Object>} entitiesAttributes Attributes of all entities.
     * @returns {Array<Object>} Cardinalities of sets by values of attributes.
     */
    static determineSetCardinalities(entitiesAttributes) {
        // Assume that all records for attributes of entities have the same
        // properties, like rows of a table with the same columns.
        // Determine attributes.
        var attributes = Object
            .keys(entitiesAttributes[0]).filter(function (key) {
                return (key === "compartments" || key === "processes");
            });
        // Iterate on attributes.
        return attributes.map(function (attribute) {
            var entityAttributeValues = Cardinality
                .collectEntityAttributeValues(attribute, entitiesAttributes);
            var metaboliteValues = Cardinality
                .translateEntityAttributeValues(
                    entityAttributeValues.metabolite, "metabolite"
                );
            var reactionValues = Cardinality
                .translateEntityAttributeValues(
                    entityAttributeValues.reaction, "reaction"
                );
            var entityValues = [].concat(metaboliteValues, reactionValues);
            var entityValueCounts = Cardinality
                .countEntityAttributeValues(entityValues);
            // Include the attribute in the value record for reference.
            var values = Object.keys(entityValueCounts).map(function (key) {
                return {
                    attribute: attribute,
                    metabolites: entityValueCounts[key].metabolite,
                    reactions: entityValueCounts[key].reaction,
                    value: entityValueCounts[key].value,
                };
            });
            return {
                attribute: attribute,
                values: values
            };
        });
    }
    /**
     * Collects entities' values of attributes.
     * @param {string} attribute Attribute of interest.
     * @param {Array<Object>} entitiesAttributes Attributes of all entities.
     * @returns {Object<Array<string>>} Collection of values of the attribute
     * for each entity.
     */
    static collectEntityAttributeValues(attribute, entitiesAttributes) {
        // Iterate on entities.
        // Collect all values of the attribute.
        // Partition values by entity.
        return entitiesAttributes.reduce(function (collection, record) {
            // Determine the entities of the current record.
            // Entities are either metabolites or reactions.
            var currentEntity = record.entity;
            if (currentEntity === "metabolite") {
                var otherEntity = "reaction";
            } else {
                var otherEntity = "metabolite";
            }
            if (
                collection.hasOwnProperty(currentEntity) &&
                collection.hasOwnProperty(otherEntity)
            ) {
                // The collection includes records for the entities.
                // Replace the current record with a new record.
                // Update the record for the current entity.
                // Preserve the record for the other entity.
                return {
                    [currentEntity]: collection[currentEntity]
                        .concat(record[attribute]),
                    [otherEntity]: collection[otherEntity]
                };
            } else {
                // The collection does not include records for the entities.
                // Create a new record for the entities.
                // Update the record for the current entity.
                // Initiate the record for the other entity.
                return {
                    [currentEntity]: record[attribute],
                    [otherEntity]: []
                };
            }
        }, {});
    }
    /**
     * Translates records of entities' values of attribute to designate entity
     * along with value.
     * @param {Array<string>} values Values of a single attribute.
     * @param {string} entity Type of entity, metabolite or reaction.
     * @returns {Array<Object<string>>} Entities' values of an attribute.
     */
    static translateEntityAttributeValues(values, entity) {
        return values.map(function (value) {
            return {
                entity: entity,
                value: value
            };
        });
    }
    /**
     * Counts the instances of entities with each value of an attribute.
     * @param {Array<Object<string>>} entityValues Entities' values of an
     * attribute.
     * @returns {Array<Object>} Counts of entities with each value of the
     * attribute.
     */
    static countEntityAttributeValues(entityValues) {
        return entityValues.reduce(function (valueCollection, entityValue) {
            // Determine the entities of the current record.
            var currentEntity = entityValue.entity;
            if (currentEntity === "metabolite") {
                var otherEntity = "reaction";
            } else {
                var otherEntity = "metabolite";
            }
            if (valueCollection.hasOwnProperty(entityValue.value)) {
                // The collection includes a record for the value.
                // Replace the current record with a new record.
                // Increment the count for the current entity.
                // Preserve the current count for the other entity.
                var newRecord = {
                    [entityValue.value]: {
                        value: entityValue.value,
                        [currentEntity]: valueCollection
                            [entityValue.value][currentEntity] + 1,
                        [otherEntity]: valueCollection
                            [entityValue.value][otherEntity]
                    }
                };
                // New record will replace previous record in collection.
                return Object.assign({}, valueCollection, newRecord);
            } else {
                // The collection does not include a record for the value.
                // Create a new record for the value.
                // Initiate the count for the current entity to one.
                // Initiate the count for the other entity to zero.
                var newRecord = {
                    [entityValue.value]: {
                        value: entityValue.value,
                        [currentEntity]: 1,
                        [otherEntity]: 0
                    }
                };
                // New record will replace previous record in collection.
                return Object.assign({}, valueCollection, newRecord);
            }
        }, {});
    }
}

--------------------------------------------------
10 April 2017

----------

function initializeVisualQueryQueue(queue) {
    // TODO: I need to get rid of the stuff below, I think.
    // TODO: Consider if it's useful.

    // Create summary of the metabolic model.
    var summary = document.getElementById("query-summary");
    var summaryHead = document.createElement("h3");
    summaryHead.textContent = "Model Summary";
    summary.appendChild(summaryHead);

    var summaryDetails = document.createElement("ul");

    var metaboliteDetail = document.createElement("li");
    metaboliteDetail.textContent = "Metabolites: " +
        Object.keys(model.network.nodes.metabolites).length;
    summaryDetails.appendChild(metaboliteDetail);

    var reactionDetail = document.createElement("li");
    reactionDetail.textContent = "Reactions: " +
        Object.keys(model.network.nodes.reactions).length;
    summaryDetails.appendChild(reactionDetail);

    // TODO: Consider adding summary for count of links, metabolite sets, process sets, compartment sets, etc...

    summary.appendChild(summaryDetails);

}

----------

function appendQueryStep(queue) {
    
    // TODO: Old stuff...
    
    var steps = d3
        .select("#query-queue")
        .selectAll("div.query-step")
        .data(queue)
        .enter()
        .append("div")
        .attr("class", "query-step");
    var count = steps
        .append("div")
        .attr("class", "query-step-count");
    count
        .append("h3")
        .text(function (data, index) {
            return "Step " + (index + 1).toString();
        });
    var detail = steps
        .append("div")
        .attr("class", "query-step-detail");
    detail
        .append("div")
        .text(function (data) {
            return "... " + data.combination;
        });
    detail
        .append("div")
        .text(function (data) {
            return data.type;
        });
    detail
        .append("div")
        .text(function (data) {
            return data.entity + " " + data.attribute + "= " + data.value;
        });
    var summary = steps
        .append("div")
        .attr("class", "query-step-summary");
    summary
        .append("div")
        .text(function (data) {
            return "metabolites: " + data.collection.metabolites.length;
        });
    summary
        .append("div")
        .text(function (data) {
            return "reactions: " + data.collection.reactions.length;
        });
}

--------------------------------------------------
6 April 2017

----------

----------
/**
 * Script for query portion.
 * Use an immediately-invoked function expression (IIFE) to establish scope in a convenient container.
 * An alternative style would be to declare the function and subsequently call it.
 */
function initializeQueryInterfaceOld() {
    // Create single instance objects of each view's class.
    // Pass instance objects as arguments to classes that need to interact with them.
    // This strategy avoids creation of replicate instances of each class and enables instances to communicate together.
    //var explorationView = new ExplorationView();
    //var navigationView = new NavigationView(explorationView);
    //var queryView = new QueryView(navigationView);

    // TODO: Allow the user to select the directory path and file of the metabolic model.
    // TODO: readdirSync from Node.js might work.
    createDataElements(
        d3.select("#selector"),
        "option",
        ["model_h-sapiens_recon-2.json"]
    )
        .text(function (d) {
            return d
        });

    d3.select("#assemble")
        .on("click", function () {
            //console.log(d3.event);
            //console.log(d3.event.srcElement.value);
            //console.log(d3.event.target.value);
            //self.dataFile = d3.event.target.value;
            //console.log(this.node().value);
            var dataFile = d3.select("#selector").node().value;

            // Load data from file in JSON format.
            // Create objects that associate with these data.
            d3.json(("../model/homo-sapiens/" + dataFile),
                function (error, modelInitial) {
                    if (error) throw error;
                    // Call function to assemble model.
                    assembleModel(modelInitial);
                });
        });
}

--------------------------------------------------
24 March 2017

<!-- Temporary pattern for table -->
<table>
  <thead>
    <tr>
      <th>Identifier</th>
      <th>Name</th>
      <th>Include</th>
      <th>Exclude</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td></td>
      <td></td>
      <td><input name="step-1-row-1" type="radio" value="include"></td>
      <td><input name="step-1-row-1" type="radio" value="include"></td>
    </tr>
  </tbody>
</table>

--------------------------------------------------
20 March 2017

function manageInterface() {
    // Activate file selector.
    document
        .getElementById("file-selector")
        .addEventListener("change", function (selectorEvent) {
            // Activate assemble button with appropriate file path.
            document
                .getElementById("assemble-model")
                .removeEventListener("click");
            document
                .getElementById("assemble-model")
                .addEventListener("click", function (buttonEvent) {
                    controlModelAssembly(
                        document.getElementById("file-selector").value
                    );
                });
            // Activate load button with appropriate file path.
            document
                .getElementById("load-model")
                .removeEventListener("click");
            document
                .getElementById("load-model")
                .addEventListener("click", function (buttonEvent) {
                    controlModelLoad(
                        document.getElementById("file-selector").value
                    );
                });
        });
}

--------------------------------------------------
21 February 2017

function collectEgoNetworkOld(ego, collection, direction, depth) {
    if (direction === null) {
        return collection.breadthFirstSearch({
            roots: ego,
            visit: function (index, depthCurrent) {
                if (depthCurrent > depth) {
                    return false;
                }
            },
            directed: false
        });
    } else if (direction === "out") {
        return collection.breadthFirstSearch({
            roots: ego,
            visit: function (index, depthCurrent) {
                if (depthCurrent > depth) {
                    return false;
                }
            },
            directed: true
        });
    } else if (direction === "in") {
        // With the current implementation of breadthFirstSearch in
        // CytoScape.js, and because of bidirectional edges, I cannot use this
        // breadthFirstSearch strategy to obtain the ego network with only edges
        // towards the ego.
    }
}




--------------------------------------------------
14 February 2017

////////////////////////////////////////////////////////////////////////////////
// Assembly of Network

/**
 * Assembles a CytoScape.js network from information of a metabolic model.
 * @param {Object} model Information of a metabolic model from systems biology.
 * @returns {Object} An object with a key of "network" and a value of a
 * CytoScape.js network.
 */
function assembleNetwork(model) {
    return {
        network: cytoscape({
            elements: {
                edges: createReactionLinks(model.reactions),
                nodes: [].concat(
                    createMetaboliteNodes(model.metabolites, model.reactions),
                    createReactionNodes(
                        model.reactions, model.metabolites, model.genes
                    )
                )
            }
        }).json()
    };
}

////////////////////////////////////////////////////////////////////////////////
// Assembly of Network

/**
 * Assembles a CytoScape.js network from information of a metabolic model.
 * @param {Object} model Information of a metabolic model from systems biology.
 * @returns {Object} An object with a key of "network" and a value of a
 * CytoScape.js network.
 */
function assembleNetwork(model) {
    return {
        network: cytoscape({
            elements: [].concat(
                createMetaboliteNodes(model.metabolites, model.reactions),
                createReactionNodes(
                    model.reactions, model.metabolites, model.genes
                ),
                createReactionLinks(model.reactions)
            )
        }).json()
    };
}




--------------------------------------------------
1 February 2017

    var subNetwork = cytoscape({
        container: document.getElementById("exploration"),
        elements: [
            {
                data: {
                    id: "a"
                }
            },
            {
                data: {
                    id: "b"
                }
            },
            {
                data: {
                    id: "c"
                }
            },
            {
                data: {
                    id: "d"
                }
            },
            {
                data: {
                    id: "e"
                }
            },
            {
                data: {
                    id: "ab",
                    source: "a",
                    target: "b"
                }
            },
            {
                data: {
                    id: "ac",
                    source: "a",
                    target: "c"
                }
            },
            {
                data: {
                    id: "ad",
                    source: "a",
                    target: "d"
                }
            },
            {
                data: {
                    id: "ae",
                    source: "a",
                    target: "e"
                }
            }
        ],
        layout: {
            name: "concentric"
        }
    });
    console.log(subNetwork);



--------------------------------------------------
31 January 2017

// Return a single array for each reaction.
function controlReactionLinks2(reaction) {
    // Determine whether or not the reaction is reversible.
    var reversible = determineReversibility(reaction);
    if (!reversible) {
        // Reaction is not reversible.
        return Object.keys(reaction.metabolites)
            .map(function (metaboliteIdentifier) {
                // Determine whether the metabolite is a reactant or a product
                // in the reaction.
                // In a reaction, assume that a metabolite only participates as
                // either a reactant or a product, not both.
                if (determineReactionMetaboliteRole(
                        reaction, metaboliteIdentifier
                    ) === "reactant") {
                    // Metabolite participates as a reactant in the reaction.
                    return createReactionLink(
                        metaboliteIdentifier, reaction.id
                    );
                } else if (determineReactionMetaboliteRole(
                        reaction, metaboliteIdentifier
                    ) === "product") {
                    // Metabolite participates as a product in the reaction.
                    return createReactionLink(
                        reaction.id, metaboliteIdentifier
                    );
                }
            });
    } else if (reversible) {
        // Reaction is reversible.
        return Object.keys(reaction.metabolites)
            .map(function (metaboliteIdentifier) {
                return [].concat(
                    createReactionLink(metaboliteIdentifier, reaction.id),
                    createReactionLink(reaction.id, metaboliteIdentifier)
                );
            })
            .reduce(function (accumulator, currentValue) {
                return accumulator.concat(currentValue);
            }, []);
    }
}

function createReactionNode(reaction, model) {
    var reactionNode = {
        group: "nodes",
        class: "reaction",
        data: {
            chemicals_change: determineChangeChemicals(reaction),
            compartments_change: determineChangeCompartments(reaction),
            compartments: determineReactionCompartments(
                reaction, model.compartments
            ),
            gene_reaction_rule: reaction.gene_reaction_rule,
            id: reaction.id,
            lower_bound: reaction.lower_bound,
            metabolites: Object.assign({}, reaction.metabolites),
            multiple_compartments: determineMultipleCompartments(reaction),
            name: reaction.name,
            products: determineReactantsProducts(
                reaction, model.metabolites, "products"
            ),
            reactants: determineReactantsProducts(
                reaction, model.metabolites, "reactants"
            ),
            reversibility: determineReversibility(reaction),
            subsystem: reaction.subsystem,
            upper_bound: reaction.upper_bound
        }
    };
    return reactionNode;
}


function createMetaboliteNode(metabolite, model) {
    var metaboliteNode = {
        group: "nodes",
        class: "metabolite",
        data: {
            abbreviation: determineMetaboliteAbbreviation(metabolite.id),
            charge: metabolite.charge,
            compartment: determineCompartment(
                metabolite.compartment, model.compartments
            ),
            compartmental_reactions: determineCompartmentalMetaboliteReactions(
                metabolite.id, model.reactions
            ),
            compartments: determineMetaboliteCompartments(
                metabolite.id, model.metabolites, model.compartments
            ),
            formula: metabolite.formula,
            id: metabolite.id,
            name: metabolite.name,
            reactions: determineMetaboliteReactions(
                metabolite.id, model.reactions
            ),
            reactions_by_compartment: determineMetaboliteCompartmentalReactions(
                metabolite.id, model.reactions
            )
        }
    };
    return metaboliteNode;
}

--------------------------------------------------
13 January 2017

function determineCompartments(model, reaction) {
  var compartmentAbbreviations = determineCompartmentAbbreviations(reaction.metabolites);
  var compartmentsTemporary = compartmentAbbreviations
    .map(function (abbreviation) {
      var pair = {};
        pair[abbreviation] = model.compartments[abbreviation];
        return pair;
    });
  var compartments = Object.assign(compartmentsTemporary[0], compartmentsTemporary[1], compartmentsTemporary[2], compartmentsTemporary[3]);
  return compartments;
};


--------------------------------------------------
2 December 2016


----------
Also Doesn't Work
----------

class ExplorationView {
...
draw() {
...

}
}

----------
Also Doesn't Work
----------

class ExplorationView {
...
draw() {
...
        // I wanted to use groups for nodes instead of circles...
        self.nodes = self.explorationSVG
            .append("g");
        self.nodeGroups = self.nodes
            .selectAll("g")
            .data(Object.values(self.model.nodes));
        self.nodeGroups
            .exit()
            .remove();
        self.nodeGroupsEnter = self.nodeGroups
            .enter()
            .append("g");
        self.nodeGroups = self.nodeGroupsEnter
            .merge(self.nodeGroups);

        self.nodeGroups
            .call(d3.drag()
                .on("start", dragStart)
                .on("drag", dragged)
                .on("end", dragEnd)
            )
            .on("dblclick", release);

        self.nodeCircles = self.nodes
            .selectAll("circle")
            .data(function (d) {
                return d;
            });
        self.nodeCircles
            .exit()
            .remove();
        self.nodeCirclesEnter = self.nodeCircles
            .enter()
            .append("g");
        self.nodeCircles = self.nodeCirclesEnter
            .merge(self.nodeCircles);
        self.nodeCircles
            .attr("class", function (d) {
                var type = d.type;
                if (type === "metabolite") {
                    return "node-metabolite";
                } else if (type === "reaction") {
                    return "node-reaction";
                };
            });

}
}

----------
Doesn't Work
----------

class ExplorationView {
...
draw() {
...

        self.nodes = self.explorationSVG
            .append("g");
        self.nodeGroups = self.nodes
            .selectAll("g")
            .data(Object.values(self.model.nodes));
        self.nodeGroups
            .exit()
            .remove();
        self.nodeGroupsEnter = self.nodeGroups
            .enter()
            .append("g");
        self.nodeGroups = self.nodeGroupsEnter
            .merge(self.nodeGroups);

        self.nodeGroups
            .call(d3.drag()
                .on("start", dragStart)
                .on("drag", dragged)
                .on("end", dragEnd)
            )
            .on("dblclick", release);

        // This strategy does not work.
        // It starts right after creating the groups for nodes.
        // They inherit data... but I don't think they inherit position.
        self.nodeCircles = self.nodeGroups
            .append("circle")
            .attr("class", function (d) {
                var type = d.type;
                if (type === "metabolite") {
                    return "node-metabolite";
                } else if (type === "reaction") {
                    return "node-reaction";
                };
            })

        self.nodeLabels = self.nodeGroups
            //.filter(function (d) {
            //    return (d.type == "metabolite");
            //})
            .append("text")
            .text(function (d) {
                return d.identifier;
            });
}
}




----------
Original Version
----------

class ExplorationView {
...
draw() {
...

        // Create nodes.
        self.nodes = self.explorationSVG
            .append("g")
            .selectAll("circle")
            .data(Object.values(self.model.nodes))
            .enter()
            .append("circle")
            .attr("class", function (d) {
                var type = d.type;
                if (type === "metabolite") {
                    return "node-metabolite";
                } else if (type === "reaction") {
                    return "node-reaction";
                };
            })
            .call(d3.drag()
                .on("start", dragStart)
                .on("drag", dragged)
                .on("end", dragEnd)
            )
            .on("dblclick", release);

        // Create titles for nodes so that mouse hover will display title.
        self.nodes.append("title")
            .text(function (d) {
                return d.name;
            });
}
}


--------------------------------------------------
30 November 2016

class ExplorationView {
...
update() {

        self.node.on("mouseover", function (d) {
            ...
            // Display panel in top left of view with information about the node.
            // TODO: Make this a group so that it can include text elements in addition to the rectangle.
            self.panel = self.explorationSVG
                .append("g");
                //.data(d);
            self.panel
                .append("rect")
                .attr("x", 5)
                .attr("y", 5)
                .attr("width", 250)
                .attr("height", 125)
                .attr("fill", "black")
                .attr("fill-opacity", 0.25)
                .attr("stroke", "black")
                .attr("stroke-width", 5);
                //.attr("class", "panel")
            //self.panel
            //    .append("text")
            //    .attr("x", 25)
            //    .attr("y", 25)
            //    .text(function (d) {
            //        return d.type;
            //    })
        }
        self.node.on("mouseout", function (d) {
            ...
            // Remove panel in top left of view with information about the node.
            self.panel.remove()
        }
}
}



class ExplorationView {
...
initialize() {
        // Create SVG element.
        // Set dimensions of SVG proportional to dimensions of the viewport or window.
        // Definition of margin, border, and padding is in the style.
        // Define padding again here since it is difficult to access element dimensions without padding.
        // Also artificially adjust height to leave room for the selector.
        // Select element for network view from DOM.
        self.explorationDiv = d3.select("#exploration");
        // Determine element dimensions.
        self.padding = {top: 10, right: 10, bottom: 10, left: 10};
        self.bounds = {width: (self.explorationDiv.node().clientWidth), height: (self.explorationDiv.node().clientHeight)}
        self.svgWidth = self.bounds.width - (self.padding.left + self.padding.right);
        self.svgHeight = self.bounds.height - (self.padding.top + self.padding.bottom);
        // Create SVG element.
        self.explorationSVG = self.explorationDiv.append("svg")
            .attr("width", self.svgWidth)
            .attr("height", self.svgHeight);
}
}


--------------------------------------------------
28 November 2016

I originally used D3 in the JavaScript script to create Scalable Vector Graphics elements within my DIV elements.
Then I decided that these SVG elements neither depend on data nor on user interaction.
I decided instead to create these SVG elements in the HTML and style them in the CSS.
Since I learned some neat things (such as methods to scale elements relatively), I want to keep the code.

class QueryView {
...
initialize() {
        // Create SVG element with a rectangle as a temporary space-filler.
        // Set dimensions of SVG proportional to dimensions of the viewport or window.
        // Definition of margin, border, and padding is in the style.
        // Define padding again here since it is difficult to access element dimensions without padding.
        // Also artificially adjust height to leave room for the selector.
        self.padding = {top: 20, right: 10, bottom: 20, left: 10};
        self.queryDiv = d3.select("#query");
        self.bounds = {width: (self.queryDiv.node().clientWidth), height: (self.queryDiv.node().clientHeight)}
        self.svgWidth = self.bounds.width - (self.padding.left + self.padding.right);
        self.svgHeight = self.bounds.height - (self.padding.top + self.padding.bottom);

        self.querySVG = self.queryDiv.append("svg")
            .attr("width", self.svgWidth)
            .attr("height", self.svgHeight);
        self.querySVG.append("rect")
            .attr("x", 0)
            .attr("y", 5)
            .attr("width", self.svgWidth)
            .attr("height", self.svgHeight)
            .attr("fill", "grey");
}
}
